Inventory tracking web application with backend Spring Boot
===

# Run the application on Repl.it:
https://replit.com/@SimiSemi/inventory-tracking-tool#README.md
## How to run
1) The application runs from the built .jar file. In the shell type:
```$ java -jar target/inventoryTrackingTool-0.0.1-SNAPSHOT.jar```
2) The web app is now live on localhost:8080. It is accessible from replit's built in Mozilla browser.
## If this doesn't directly work, then:
1) Sometimes replit won't open the browser by default so what I found to be useful is the following: First cd into ```inventory_tracking_frontend```, and run ```$ npm start```. This only runs the front-end, but it will make replit open up the mozzilla browser. Keep it open, go back to the shell and interrupt the current process. $```cd ..``` back into the main folder and run the same command as in 1), and the webb app should be live on localhost:8080.
2) If by any chance the built .jar file is missing from the target folder, then (in the main project directory) type in the shell: ```$ mvn clean install```, and it will generate it (this might take a few mins). After it finished, type again the same command as in 1) to start the application.

# About the app

## How to use
1) On the left side of the screen there are two sections: the 'add item' section and the view 'all items' sections. The React hooks implemented allow for instantaneous updates on the front-end, so whenever you create, delete or update an object the changes are immediately reflected in the frontend. You can add a new item to your collection of items and give it a name, price, description and total stock. This stock is later used to properly assign inventory in discrete warehouse locations.
2) On the right side of the screen similar sections are available, but for the warehouse object. You can create and delete them as you wish.
3) In the middle of the screen there is a 'move item' section. This takes care of the interaction between an inventory of items and a warehouse. You can select an item's ID to move, the quantity of item to move, and a destination (warehouse) to move to. If you want to move an item from the unassigned space into a warehouse, select the item's ID which you want to move and in the 'warehouse (destination)' field select one warehouse from the ones available. Then select a quantity and press 'move'. If you want to remove a quantity of items from a warehouse, do the same thing, but press the 'remove' button. It is also possible to move a quantity of items between two warehouses (let's say a part of the shipment has moved across two depots and we want to reflect this into our application), then select the item's id to move, the quantity, the 'warehouse (origin)' (the warehouse the items are moving from), and the 'warehouse (destination)' (the warehouse the items should end up into), and press 'move'. Again for all of these actions, the frontend will show immediate responses (so no refreshes are required).

## Expected behaviours
1) It is possible to update an item's stock (equivalent to a higher supply in a real world scenario). Doing so, will be reflected also in the item's 'available stock' field. This is basically the amount of items that are free to be moved to a warehouse. This stock can also have a negative update, reflecting into a less quantity of items that are available to be moved to a different warehouse. But in some scenarios: i.e all stock of a particular item has already been assigned to multiple warehouses, and we have 0 'available stock', we now modify the total stock we have, to something less than what we previously had. This will yield a negative number in the 'available stock' field. Instead of restricting this behaviour I chose to allow it, since negative values can be useful in real life scenarios. In this case it would be a telling of how much more stock I have to acquire, in order to be able to fulfill all my requirements.
2) If you try to move an item from a warehouse to another warehouse, and that warehouse doesn't have that item, this action will not go through (for obvious reasons). The same will happen if you try to move a larger quantity of items than what you currently have in the warehouse (this is physically impossible)
3) Negative stock quantities are also not allowed, and the backend will also reject this request.
4) When deleting a warehouse that already contains items of some quantities, those respective quantities will be automatically moved back into the free 'available stock' field. This would be a real life interpretation of somebody choosing to discard the usage of a warehouse, and the application reflects this by telling him how much new 'free stock' is there to move to another warehouse
5) When deleting an item that a stock of it has already been assigned to the warehouse, the item will also be automatically discarded from the warehouse's inventory too, in order to avoid all possible troubles in the future i.e trying to move an item from a warehouse to another but that item no longer exists in our database.
6) When adding a new item, and the stock is not set (so its null), the item still goes through and its added successfully, but you are restricted from moving it to warehouses (it can only exist in the database as a 'ghost' entity). This is a real life application of a new item being added to the list of items, but maybe that product isn't yet ready for manufacturing (or maybe it doesn't yet have a producer), so we can still have it but, we can't physically move it anywhere since there isn't any material copies of it. When trying to move an item with null quantity in the web app, nothing will happen, since all restrictions are directly implemented in the back-end.

## Structure
1) The backend is built using Spring Boot in Java and the database is a simple local storage H2 database. The frontend is built using React and typescript.
2) The project is very minimal consisting only of a few packages: the controller, the model, the services, and the repository. The model package only contains the two entities we model for our web application to function: the Item class and the Warehouse class. The controllers have the rest endpoints needed to do all necessary updates and insertions of objects for our database. I used hibernate to simply model the relations between these classes. I use dependency injection and Spring's 'autowire' for the services, in order to keep the codebase cleaner and more readable.
3) All objects respect basic CRUD functionality. 

# Design choices
1) A warehouse's inventory is modelled using a simple HashMap<Long, Integer>, representing a map between an item's ID and its corresponding quantity in that warehouse. I chose this approach as this reduces the overall memory that a database would have to use. It would be redundant to store again another List of Items (same entity), as we already have all the necessary information about an item's properties in the Item table. We only use its ID, since it uniquely identifies an item, and if we want more information about said item, a simple endpoint ('get/{id}') will retrieve all the information we want. Map's have very efficient retrieval and update access times, so it was the only logical choice for this implementation, as we can update an item's properties or look for them in our warehouse in constant time. With this approach we reduce both server memory and server load.
2) If a move between two warehouses (transporting an item of quantity x) goes wrong in the middle, the backend will report this in the logs, and reverse the operation back to the last correct status. I chose to model it like this, since I believe keeping the integrity and correctness of a model is the most important part. In my approach, I first remove the said item with quantity x from the origin warehouse, then add the same item with quantity x to the destination. If this operation fails somewhere in the middle, both warehouses will go back to the previous state, making it as if the operation never went through. In a real world scenario we want to avoid these inconsistencies as much as possible, so I tried to model everything very dependent on another state's success.
3) Most illegal moves are restricted, as mentioned above: trying to move a quantity of items which has insufficient volume available, moving inexistent items, adding items with negative stock, or removing items with negative stock, selecting invalid destinations or origins for the warehouses etc. But feel free to play around and spot any bugs if you find any!
4) I used H2 instead of any other popular alternatives (MySql, Postgres), since it was the most lightweight approach that surely worked. I was not familiar with Replit, and neither its built in database so I chose to use the file system storage, as this web app is only proof of concept only. 
 
# Checkstyle & documentation & testing
For the checkstyle I used the classic Google-java-format checkstyle, and for the documentation I did JavaDoc for each method. For testing, I only did basic Unit testing for my classes, as I didn't see the need for mocks or integration testing at a project of this low level. i.e mocking repositories that connect to a local small storage database, wired with hibernate that only uses two entities didn't seem that necessary
